                                                             ----------Java Notes----------


Object Oriented Programming : It is an approach that provides a way of modularizing programming, that which can be used to create small partition memory area for both data and objects, which are to be used as templates for creating copies of such modules on demand. 

Object :

An object is a real world entity, that which possess 3 characterstics known as
	
	(i) State

	(ii) Behaviour

	(iii) Identity 

OOPS Features : 
________________

1) Encapsulation : Wrapping up of data and functions into a single unit known as encapsulation. 

2) Abstraction : Hiding the irrelevant details of an object, that do not contribute to its essential characterstics known as Abstraction. 

  *** Encapsulation focuses on showing the relevant details where, abstraction focuses on hiding the irrelevant details. ***

3) Inheritance : Deriving a new entity from already existing entity known as inheritance, through inheritance we can reduce the size of the program.

4) Polymorphism : The ability to take more than one form known as polymorphism. 

class : A class is a template or blueprint, that which contains combination of data members and member functions.  Members of the class can be accessable by using instance of the class. 

class class_name
{
   data members;
   member functions;
}

Why Java : 
__________

1) Platform Independence : Write Once and Run anywhere. 

2) Console/Windows/Web/Serivce Oriented/Mobile Apps : 

3) Packages 

__________________________________________________

Java Features : 
__________________


(i) Simple : Java uses simple C/C++ syntaxes, as programmer no need to take care of internal details like memory management etc...As how much memory allocated to run the program, the same amount of memory will be reallocated automatically. 

(ii) Object Oriented : Java supports all object oriented programming features. 

(iii) Compiled and Interpreted : Java programs are compiled first, during compilation java code will be converted into bytecode, then .class file will be created. In interpretation it reads the bytecode line by line and executes. 

(iv) Portable : Ability to run the program without changing the source code, java programs are programs that can run on any env. without changing the source code. 

(v) Securable : Java implements various levels of security as

	(i) Compiler Level

	(ii) Bytecode Level

	(iii) Class Loader Level

(vi) Distributed 

 By using java, we can make all distributed and robust applications. 

Java Architecture : 
___________________


	(i) Java Program : Java code that which stored with extension .java

	(ii) Java Class : Java code after compilation its converted into bytecode

	(iii) JVM (Java Virtual Machine) 

		(a) Class Loader : Used to load all classes which are required to 		run the program. There are 2 types of class loaders known as

			(i) Primordial Class Loader

			(ii) Class Loader Objects 


		(b) JIT Compiler : Converts bytecode into CPU specific format. 

		(c) Execution Manager : Contains QUEUE of programs which are ready to run where we can execute the program. 

	*** Before execution, needs to undergone security authentication ***

	(iv) Java API : It provides runtime env, that which allows you to run the java program. As there are 2 components as

		(a) JDK  (b) JRE


The default package in java is lang, as we can define as java.lang

The top level class in java is Object, as we can define as java.lang.Object

Data Types : 

There are various types of data types as

(i) Value Types : int, float, double, byte, char, boolean 

(ii) Reference Types : String, Object and Custom Objects

*** value types will be stored in STACK memory and reference types will be stored in HEAP memory ***

System.out.println() 

System ->  class

out ->  Console

println()  ->  method. 

System.out.println("Welcome to Java Programming...");

You can define method main() as 

public static void main(String[] args) {

}



main() method must be static as no class object supposed to call method main()


Access Modifiers : 
_____________________

1) private  : Allows you to access members within current class. 

2) public : Allows you to access members in entire application. 

3) protected : Allows you to access members within current/derived class. 

4) friendly : By default java possess friendly access modifier, allows you to access members within all classes of current package. 

You can create an object to the class, as

class_name obj = new class_name();

Control Structures : 
____________________

Used to define the flow of the program. 

There are 2 types of control structures known as 

(i) Branching

if...else : Executes the statement(s) based on the condition. 

if (condition) {
	statement(s);
} else {
	statement(s);
}

switch...case : Used to define menu-driven programs. 



(ii) Looping 

while loop : This loop executes all the statement(s) repeatedly until the condition remains true, if the condition remains false, then it comes out of the loop. 

For every loop, we have 3 phases as 

	(i) Initilization

	(ii) Condition

	(iii) Increment/Decrement 

Initilization performed at the beginning of the loop.

Condition performed at the conditional part of the loop.

Increment/Decrement performed before closing the loop. 

while(condition) {
   statement(s);
}

for loop : This loop executes all the statements repeatdly until the condition remains true.

for(initialization;condition;increment/decrement) {
...
...
...
}

Arrays : An array is the finite ordered set of homogeneous elements, means all the elements belongs to same data type. 

All the elements of array are stored in successive memory locations. 

int[] a = new int[]{12,5,33,23,66};

a[0]=12;
a[1]=5;
a[2]=33;
a[3]=23;
a[4]=66;

How internally foreach loop will work ???
int[] a = new int[] {12,4,33,653,23};
//		for(int i=0;i<a.length;i++) {
//			System.out.println(a[i]);
//		}
		for (int i : a) {
			System.out.println(i);
		}

In this above loop, at first i points to the first element in array A, after processing first element, it checks next element is there or not by using hasMoreElements(), it hasMoreElements() returns true, it moves to the next element by using nextElement(). It repeats as soon as hasMoreElements() is true. 

public class Quiz1 {
   public static void main(String[] args) {
	System.out.println("5"+3+8);
	System.out.println("5"+(3+8));
	System.out.println("5+3"+8);
  }
}

public class Quiz2 {
   public static void main(String[] args) {
	int x;
	System.out.println(x);
   }
}

public class Quiz3 {
   public static void main(String[] args) {
	int x=10;
	int y=x++;
	System.out.println(x + " " +y);
   }
}

public class Quiz4 {
   public static void main(String[] args) {
	int x=10;
	int y=x++ + x++ + ++x + ++x;
            // 10 + 11 + 13 + 14
	System.out.println(x + " " +y);
   }
}

public class Quiz5 {
   boolean climate;
   public static void main(String[] args) {
	System.out.println(new Quiz5().climate);
   }
}


public class Quiz6 {
   public static void main(String[] args) {
	int ch='A';
	System.out.println(ch);
   }
}

public class Quiz7 {
   public static void main(String[] args) {
	System.out.println(args[0] + " " + args[2]);
   }
}

java Quiz7 Ayush Rahul Khafia Jitendra

public class Quiz8 {
    public static void main(String[] args) {
	byte b=125;
	b+=10;	
	System.out.println(b);
   }
}

public class Quiz9 {
    public static void main(String[] args) {
	String s1="Hello";
	s1.concat(" World");
	System.out.println(s1);
   }
}


Task 1: 

Write a Program to implement current bill as read no.of units and generate bill based on slabs given below

	first 90 units 1 rs per unit
	91 to 150 units 1.5 rs per unit
	151 to 200 units 2 rs per unit
	200 to 240 units 2.5 rs per unit
	240+ units 3 rs per unit 

Case 1 : If units are 95 then bill is (90 * 1 ) + (5 * 1.5)
Case 2 : If units are 155 then bill is (90 * 1) + (60 * 1.5) + (5 * 2) 
Case 3 : If units are 205 then bili is (90 * 1) + (60 * 1.5) + (50 * 2) + (5 *2.5)


Day - 2

Boxing and Unboxing : 

The concept of converting value types to reference type known as boxing, and refernce type to value type known as unboxing. 

Object is the type, that which can be used for boxing and unboxing. 

int x;

x="Hello";
x=12;
x=12.5;

Object x;

x="Hello";
x=12;
x=12.5

enum : used to store group of constarnt values, which can be used as user-defined data type. 

Method overloading : The concept of using the same method name w.r.t. different data types or different parameters known as method overloading.  Here, the method name must be same. 

class Test {
   int x, y;
   x=12;
   y=13;
}

Constructors : A constructor is a special member which used to initilize the member variables of the class, it is special because it has the same name as that of class name. 

Rules : 
_________

	(i) It will not contains any return type

	(ii) It will not return any value

	(iii) Constructors can be overloaded. 

Types of Constructors : 
________________________

There are 2 types of constructors 

	-> static constructors : These are called class constructors, which are used to initilize the static variables of the class, these constuctors are invoked automatically before control reaches the entry point. These constructors cannot be overloaded. (*** In java, we don't have static constructors, as static {} acts as static constructor ***) 

	-> Instance constructors : These are the constructors that which are invoked automatically once the instance of the class created. These constructors can be overloaded. 

static variables : These are the class variables, that which retains values irrespective of type of object. 

Inheritance : The concept of deriving a new class from already existing class known as inheritance, the class which derived known as derived class, the class from which its derived known as base class. Through inheritance, we can reduce the size of the program. 

class First {
...
...
...
}

class Second extends First {
...
...
...
}

Once you create an object to Second class, then you can access all public/protected and friendly members of base class. 

super keyword : If you want to pass values from derived class to base class, then we need the help of super keyword. It has 2 forms as

1) super as a keyword

2) super as a constructor

Abstract Class : 
________________

A class, that which can be created, but not implemented and instantiated known as abstract class. Abstract class contains abstract and non-abstract methods, abstract methods needs to be overrided mandetorily by the derived class. 

abstract class class_name {
    abstract method1();
    abstract method2();
}

interfaces : 
_____________

Java does not support the concept of multiple inheritance, to achieve this we need the help of interfaces. 

An interface contains method declaration, and the implementation can be done in the corresponding class, you can add more than one interface to the particular class. 

Difference between interface and Abstract Class : 
__________________________________________________

   -> An abstract class contains both abstract and non-abstract
		methods, where interface contains only
		abstract methods. 

   -> Interface methods are public and abstract by default.

   -> Multiple Inheritance can be achieved by using interfaces

   -> An interface can be called from anywhere to anywhere. 

interface interface_name {
   method1();
   method2();
}

interface can be added to the class by using implements keyword. 

interface IOne {
  void show();
}

interface ITwo {
  void show();
}

interface IThree {
  void show();
}

class Hello implements IOne, ITwo, IThree {

}

final class : 

Final class cannot be inherited

Final methods cannot be overrided

Final variables cannot be updated. 


1) Write a Program to implement multiplication of 2 numbers (100 digit number 100 digit number) print exact result.

2) Write a program to display a number in english words

Case 1:

123 One hundred twenty Three

1234 One thousand two Hundred thirty Four

400 Four Hundred

790 Seven Hundred Ninety

Properties :-

	provides an opportunity to protect a field in a class, 

If you want to represent any variable as a field then we need the help of properties.

If you want to control the internal behaviour of particular entity then we need the help of properites

Properties are methods which are used for value types operations. 

There are 3 types of properties known as 

1) Read Only Property

2) Write Only Property

3) ReadWrite Property


A file is a collection of related records placed in aparticular area on the disk.  A record is composed of several fields and a field is a group of chars. 

Stream Classes : 

If you want to work with files, then you need to include the package java.io;

This package contains the large no.of stream classes that provides capabilities for processessing all types of data.  These classes may be catgegoriezed into two groups based on the data type on which they operate. 

1. Byte stream classes that provide support for handling input/output operations on bytes. 

2. Character stream classes that provide support for managing I/O operations on characters. 

1. InputStream Classes : These classes are used to read 8-bit bytes include a super class known as  InputStream and a no.of subclasses for supporting various input-related functions. 

2. OutputStream Classes : These classesa re dervied from the base class OutputStream. This is an abastract class and we cannot instantiate it. 

using FILE Class : java.io package includes a class known as File that provides support for creating filesw and directories. The class includes several constructors for instantiating the File Objects. 



1. File Class : 

    File(File dirobj,String filename) : Creates a new instance of the File Class. The obj. is a File object that specifies a directory. The filename arg. specifies the name of the file.

   File(String direcotyrPath) : Creates the new instance for the File class. 
   File(String directorypath,String filename) : Creates a new instance of the File class. The arg. directorypath specifies the path of the file. 

Various methods of the File Class :

1. String getName() -> Retrives the name of the specified file.

2. String getParent() -> Retrieves the name of the parent directory. 

3. String getPath() -> Retrieves the path of the specified file. 

4. String[] list() -> Displays the list of files and directories of specified directory.

1. Program to Display the properties of a file and list of files in the directory.

_____________________________________________________

Reader Stream Classes : These classes are used to read characters from the files. Reader class is the base class for all other classes in this group. 

Reader class contains methods that are identical to those availabel int he InputStream. 

Writer Stream Classes : These classes are designed to perform all output operations on files. Only difference is that while output stream classes are designed to write bytes, the writer steram clases are designed to write characters. 

FileInputStream 
________________

Used to perform operations on the file such as reading data from the file. 

1. FileInputStream(File f) : Creates a file input stream that connects to an existing file to be used as data source. File object specifies the name of the file 

File f=new File("c:\\java","file1.txt");

FileInputStream f1=new FileInputStream(f);

2. FileInputStream(String s) : Creates a file input stream that connects to the existing file to be used as a data source. The path of the file in file system is given by the string arg. 

FileInputStream f=new FileInputStream("c:\\java.txt");

_____________________________________________________________

Handling Primitive Data Types : 

To handle primitive data types, for this we need the help of DataOutputStream class. 

The classes DataInputStream and DataOutputStram used to handle the primitive data types. 

FileInputStream fis=new FileInputStream("f1.java");
DataInputStream din=new DataInputStream(fis);

FileOutputStream fout=new FileOutputStream("f1.java");
DataOutputStream dout=new DataOutputStream(fout);

_______________________________________________________________________

java also supports the creation of buffers to store temporarily data that is read from or written to a stream. The process is known as buffered i/o operation. A buffer sits with program and source and functinos like a filter. Buffers can be created by using BufferedInputStream and BufferedOutputStream. 

_______________________________________________________________________

DataInputStream : If you want to read the custom input, then we need the help of DataInputStream. 

_________________________________________________________________________

ObjectInputStream -> It is used to deserialize the primitive data and objects that are written using the ObjectOutputStream. 

Methods : 

  1. readObject() -> used to read an object from the ObjectInputStream. 
  2. Close() -> Used to close the particular stream.


ObjectOutputStream -> It is used to write the objects into the specified file. 

Methods :

   1. writeObject(Object obj) throws Exception : Writes an object into the stream. 
   2. flush() throws Exception : Ensures that the data stored in the buffer is written to a file to which the stream is connected.    
   3. close() -> Closes the stream and releases all the resources occupied by the stream. 

1. Prog. to work with ObjectOutputStream. 

A class implments the Serializable interface in order to serialize its objects. 

___________________________________________________________________________

Collections : 

A collection is an object that contains a group of objects within it. These objects are called the elements of the collection.  The elements of collectin descend from a common parent type.  Collections have an adv. over arrays that collectino can grow to any size unlike arrays. 

Constructors : 

1. CollectionName() -> Creates an empty collection. A void  constructor does not accept any arg.

2. CollectionName(Collection col1) : Creates a new collection that accepts a collection as an arg. and returns the collection containsing the same elements as the collection arg. 

List Interface : This interface extends the collection to handle sequence or a list of objects. Elements can be inserted in a list and can be accessed from a list using their index pos. in the list. 

Set interface : This interface extends the Collection interface to handle sets containing unique elements.  This interface does not allow any duplicate elements in a set. 

SortedSet interface : Used to extends the Set interface to handle the sorted sets. The elements of a set are ordered in ascending order in a sorted set.  

__________________________________________________________

Classes used in the Collections are : 

ArrayList class : This supports dynamic arrays that can grow as needed. In java, standard arrays are of a fixed length. after arrays are created, they cannot grow or shrink, which means that you must know in advance how many elements an array will hold. 

Working with ArrayList() class. 

1. ArrayList class : This supports dynamic arrays that can grow as needed. In java, standard arrays are of a fixed length. after arrays are created, they cannot grow or shrink, which means that you must know in advance how many elements an array will hold. 

Working with ArrayList() class. 

Prog. to demo about ArrayList().

Obtaining an Array from an ArrayList : 

-->  To obtains faster processing times for certain operations.

-->  To pass an array to a method that is not overloaded to accept a colleciton.

-->  To integrate your newer, collection-based code with legacy code that does not understand collections. 
 
Prog. to implement Array from an ArrayList. 

LinkedList() class is used to add the values into the linked list. 

HashSet : It creates a collection that uses a hash table for storage. It stores information by uing a mechanism called hashing.  

It contains the methods as add(), contains() and remove()

Prog. to implement Array from an ArrayList. 

LinkedList() class is used to add the values into the linked list. 

HashSet : It creates a collection that uses a hash table for storage. It stores information by uing a mechanism called hashing.  

It contains the methods as add(), contains() and remove()

Iterator : Display the elements of a collection class in looping order. 

1. Obtain an iterator to the start of the collection by calling the collection's iterator() method. 

2. set up a loop that makes a call to hasNext()

3. To repeat the loop goto next() method. 

Treeset : It provides an implementation of a Set interface that uses a tree for storage.  

Comparators : This interface defines two methods

methods : 

void addFirst(Object obj)
void addLast(Object obj)

To Remove the elements, 

Object removeFirst()
Object removeLast()

int[] a=new int[1000];

Vector()
Vector(int size)
Vector(int size,int incr)
Vector(Collection c)

If you want to see the available methods of a specific class, then use the java command as 

javap java.util.ArrayList
javap java.util.Vector

wrapper class : The concept of Converting the primitive data types into objects and objects into primitive data types is called wrapper. 

Hashtable : It is concrete implementation of a Dictionary.  Used store key/value pairs in a hash table. When using a Hashtable, you specify an object that is used as a key, and the value that you want linked to the key.  

Properties :  It is a subclass of Hashtable. It is used to maintain lists of values in which the key is a String and the value is also String. THe Properities class is used by many other Java Classes, and the object is returned by using System.getProperties() 

Applets are small java programs that are primarily used in internet computing. They can be transported over the internet from one computer to another and run using the Appletviewer or any web browser that supports java. An applet, like any app program, can do many things for us. java applets have bugun to make a significant impact on the WWW. 

There ar 2 types of applets available to us. 

An applet developed locally and stored in a loca system is known as local applet. When a page is trying to find a local applet, it does not need to use the internet and therefore the local system does not require the internet connection. 

A remote applet is that which is developed by someone else and stored on a remote computer connected to the internet.  If our system is connected to the internet, we can dowload the remote applet on to our system via the intenet and run it. 

In order to locate and load the remote applet, we must know the applet's address on the web. This address is known as URL and must be specified in the applet's HTML document as the value of the CODEBASE attribute. 

How applets are different from other apps.

1) Applets do not use the main() method. 
2) Unlike stand-alone apps, applets cannot be run independently. They are run from insdie a web page using a special feature known as HTML tag. 
3) Applets cannot read from or write to the files in the local computer. 
4) Applets cannot communicate with other servers on the network. 


Applets Life Cycle : 

The Applet states include : 

1) Born or initialization state
2) Running state 
3) Idle state 
4) Dead or destroyed state. 

Initialization state : Applet enters into the state when it is loaded first time. This is achieved by using the init() method. 

Running State : It enters into the running state when the system calls the start() method of Applet class. This occurs automatically after the applet is initialized. 

Idel State : When it is stopped from running it enters into idle state. 

Stopping occurs automatically when we leave the page containing the currently running applet.  We can also do so by calling the stop() method explicitly. 

Dead State : When it is remove from the memory, then it is in dead state. This occurs automatically by invoking the destroy() method when we quit the browser. This state occurs only once in the applet's life cycle. 
For Initialization state we need to use init() method. 

public void init()
{
   ....
   ....
   .... (Action)
}

For Running state we need to use start() method. 

public void start()
{
.....
.....
..... (Action)
}

Idle or Stopped State : We need to use stop() method. 
public void stop()
{
.....
.....
}
Dead State :  for this we need to use destroy() method. 
public void destroy()
{
....
....
}
If you want to display any value, then give paint() method. 
public void paint(Graphics g)
{
...
... 
}


TextBox : This class allows you to create a textbox object and that will be added to the Applet. 

TextBox t1=new TextBox(12);

add(t1);

Button : This is used to perform action events when you click on that. 

Button b1=new Button("One");
add(b1);
b1.addActionListener(this);

Once you click on this button, some action it need to be performed. For this you need actionPerfomed() method. 

By default button implements ActionListener interface. 

Passing Parameters to Applets : 

TextField : Allows you to read data into that. 

getText() : Used to read the text in the TextField.

setText() : used to place text in the textfield. 

Day - 5
--------
Exception Handling : It is a mechanism of handling the runtime errors during the execution of the program. 

There are 2 types of errors known as 

	(i) Compile Time

	(ii) Runtime Errors

By using Exception Handling, we can overcome runtime errors. 

To Handle exceptions, we have 3 blocks as

1) try block : This block contains statement(s) in which there is possibility of getting runtime errors, the statement(s) which are placed in this block are treated as heavy weighted statements as JVM allocates excess memory to them. 

2) catch block : Once exception raised in try block, then the control will be forwarded to catch block, this block contains alternate statement(s) for exceptions raised in try block. One try block can contains multiple catch blocks. 

3) finally block : This block contains statement(s) that needs to be executed mandetorily irrespective of try and catch blocks, this block is not mandetory, but all the statement(s) which are placed in this block are executed as mandetory statements. 

Exception is the top most class from which all kinds of exceptions are derived. 

try {
...
...
...
} catch (Exception e) {
...
...
...
} finally {
...
...
...
}

printStackTrace()

There are 2 types of exceptions known as 

	(i) Checked Exceptions : These are the exceptions that which occurs at compile time, during compilation JVM feels some erroneous code is there and stops the execution at compile time, can be handled at method level by using throws keyword. 

	(ii) Unchecked Exceptions : These are the exceptions that which occurs at runtime. 


Throw Keyword : If you want to throw exception based on condition, then we need the help of throw keyword. 

Assume, accept a number if number < 0 then throw ArithmeticException if number = 0 then throw NumberZeroException, else print that number. 

You can define custom exceptions by using Exception class, any class, that which derived from Exception can be treated as custom exception. 

class class_name extends Exception {
	



Write a Program to accept email, and check its valid or not 


1) if '@' not found then throw InvalidEmailException 

2) if userName length < 10 chars then throw InvalidUserException

else print the email address. 

Project 
__________


Employ
    empno
    name
    gender
    dept
    desig
    basic 

empno -> Not Negative Number
Name contains min 5 chars
gender -> Enum
dept contains min 3 chars
basic must be between 10000 and 80000

Day - 6
--------

Day - 7
--------

A file is a collection of data, that which allows you to store the output permanently. To deal with files, we need the help of java.io package. 

File class : this class allows you to deal with file propeties. 

File f1 = new File(filename);

getName()

getParent()

getPath() 

FileReader : This class allows you to read data from file w.r.t. unicode characters 

FileReader fr = new FileReader(filename);

read() -> Used to read data char/char and returns ascii value, it returns -1 once it reaches end of file. 

FileWriter : This class allows you to write contents into file. 

FileWriter fw = new FileWriter(filename);

write() : used to write data char/char .

FileInputStream : Used to read data w.r.t. Stream of bytes. 

read() : used to read data char/char and returns ascii value. 

Returns -1 if it reaches EOF.

FileOutputStream : used to write output to the given file w.r.t. Stream of bytes. 

write() : Used to write data char/char. 

DataOutputStream : used to write data w.r.t. Primitive Types. 

DataOutputStream dout = new DataOutputStream(fileName);

writeInt()
writeDouble()
writeUTF()
writeBoolean()


DataInputStream : Used to read data w.r.t. Primitive Types. 

DataInputStream din = new DataInputStream(filename);

readInt()
readDouble()
readUTF();
readBoolean()

BufferedReader : Allows you to read the data from the keyboard. 

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

ObjectOutputStream : used to write Objects into the file. 

ObjectOutputStream obj = new ObjectOutputStream(filename)

writeObject() => Used to write object into the file. 

ObjectInputStream : used to read objects from the file. 

ObjectInputStream objin = new ObjectInputStream(fin);

readObject() : Used to read objects from the file. 

Serilization : It is a process of writing the custom objects into the file. 

We can implement that by using implements keyword. 

any class that which implements Serilizable interface, those objects we can store in file. 






















